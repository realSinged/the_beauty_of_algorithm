## 堆

堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法

什么是堆：

1. 堆是一个完全二叉树

2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

大顶堆、小顶堆

### 如何实现一个堆

存储：

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

堆上的操作：

1. 插入一个元素：

    堆化(heapify)： 
    
        从下往上： 新插入的节点与父节点对比大小。如果不满足子节点小于等于(或大于等于)父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。
    
    时间复杂度： O(logN)

2. 删除堆顶元素：

    堆化：

        删除堆顶元素，把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。
    
    时间复杂度： O(logN)


### 基于堆实现排序

1. 建堆

    时间复杂度： O(n)

2. 排序

    建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。
    
    这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。

复杂度： 时间： O(NlogN), 空间：O(N)

不是稳定的排序算法，在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序

### 为什么快速排序要比堆排序性能好？

1. 堆排序数据访问的方式没有快速排序友好。

    对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。
    对 CPU 缓存是不友好的

2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

    堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。


### 堆的应用一： 优先级队列

在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。

堆实现：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。

### 堆的应用二： 求top K

### 堆的应用三： 求中位数

一个大顶堆和一个小顶堆




