## 排序

### 执行效率

最好情况、最坏情况、平均情况时间复杂度：

时间复杂度的系数、常数 、低阶：实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

比较次数和交换（或移动）次数: 

### 内存消耗

算法的内存消耗可以通过空间复杂度来衡量。原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法

### 稳定性

稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。

空间复杂度： O(1)

时间复杂度： 最好：O(n), 本来就有序。 最差： O(n2), 本来是逆序

有序度：有序度是数组中具有有序关系的元素对的个数。对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，我们把这种完全有序的数组的有序度叫作满有序度。逆序度 = 满有序度 - 有序度。

### 插入排序

数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

空间复杂度： O(1)

稳定的排序算法

时间复杂度： 最好：O(n), 本来就有序。 最差： O(n2), 本来是逆序

优化的插入排序之一： [希尔排序](https://zh.wikipedia.org/wiki/希尔排序)

### 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

空间复杂度： O（1）

时间复杂度：最好：O（n2）。 最差： O（n2）。 平均： O（n2）

不是稳定的排序算法


#### 为什么插入排序比冒泡排序更受欢迎？

代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个

### 归并排序

如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。

归并排序使用的就是*分治思想*,将一个大问题分解成小的子问题来解决


```
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
// 递归终止条件
if p >= r  then return

// 取p到r之间的中间位置q
q = (p+r) / 2
// 分治递归
merge_sort_c(A, p, q)
merge_sort_c(A, q+1, r)
// 将A[p...q]和A[q+1...r]合并为A[p...r]
merge(A[p...r], A[p...q], A[q+1...r])
}
```

归并排序是稳定的排序算法

时间复杂度：

```
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......

T(n) = 2^kT(n/2^k)+kn 
其中：
T(n/2^k)=T(1)
所以：
T(n)=Cn+nlog2n
T(n) 就等于 O(nlogn)
```

归并排序需要申请额外的存储空间，空间复杂度是O（n），不是原地排序算法。

### 快速排序

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。

```
// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
```

时间复杂度： T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)

空间复杂度： O(1)

快排是一种原地、不稳定的排序算法


