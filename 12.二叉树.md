
## 树

父节点，子节点，兄弟节点，根节点，叶节点。

高度，深度，层

## 二叉树

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点

满二叉树： 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点

完全二叉树： 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

### 如何表示（存储）一棵二叉树

1. 一种是基于指针或者引用的二叉链式存储法

每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来

2. 基于数组的顺序存储法

根结点： 下标i的位置， 左子节点： 2i， 右子节点：2i+1

不是完全二叉树，会浪费比较多的存储空间。

### 二叉树的遍历

1. 前序遍历： 对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

2. 中序遍历： 对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树

3. 后序遍历： 对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

```
    前序遍历的递推公式：
    preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

    中序遍历的递推公式：
    inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

    后序遍历的递推公式：
    postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

遍历时间复杂度： 每个节点最多被访问两次， O（n）

## 二叉查找（搜索）树

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

可以快速的查找最大节点和最小节点、前驱节点和后继节点

中序遍历二叉查找树，可以输出有序序列，时间复杂度是O（n）

### 支持重复数据的二叉搜索树

1. 节点链表

2. 遇到相同的值，放入右子树

### 二叉查找树的复杂度

时间复杂度： 

    最差： 退化为链表，O(n)
    最好： 完全二叉树， O(height), height <=log2N

### 散列表和二叉查找树的对比

1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。

2. 列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)

3. 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。

4. 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。



